const https = require('https');
const fs = require('fs');
const path = require('path');

// æ–‡ä»¶è·¯å¾„
const DATA_FILE = path.join(__dirname, '..', 'data', 'reminders.json');
const TOKEN = process.env.TELEGRAM_BOT_TOKEN;
const CHAT_ID = process.env.TELEGRAM_CHAT_ID;

// ==================== ç²¾ç¾æ—¶é—´æ ¼å¼åŒ–å‡½æ•°ï¼ˆå’Œä½ ç½‘é¡µä¸Šä¸€æ¨¡ä¸€æ ·ï¼‰====================

/**
 * è·å–ä»Šå¤©çš„æ—¥æœŸå­—ç¬¦ä¸²ï¼ˆYYYY-MM-DDæ ¼å¼ï¼‰
 */
function getTodayDateString() {
    const now = new Date();
    // è½¬æ¢ä¸ºåŒ—äº¬æ—¶é—´
    const beijing = new Date(now.getTime() + 8 * 60 * 60 * 1000);
    const year = beijing.getUTCFullYear();
    const month = String(beijing.getUTCMonth() + 1).padStart(2, '0');
    const day = String(beijing.getUTCDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}

/**
 * æ ¼å¼åŒ–æ—¥æœŸä¸ºä¸­æ–‡æ˜¾ç¤ºï¼ˆå’Œä½ ç½‘é¡µä¸Šå®Œå…¨ä¸€è‡´ï¼‰
 * è¾“å‡ºï¼šä»Šå¤©ã€æ˜å¤©ã€æ˜¨å¤©ã€2æœˆ13æ—¥(å‘¨å››) ç­‰æ ¼å¼
 */
function formatDate(date) {
    const now = new Date();
    // è½¬æ¢ä¸ºåŒ—äº¬æ—¶é—´æ—¥æœŸï¼ˆåªæ¯”è¾ƒå¹´æœˆæ—¥ï¼‰
    const beijingNow = new Date(now.getTime() + 8 * 60 * 60 * 1000);
    const today = new Date(beijingNow.getUTCFullYear(), beijingNow.getUTCMonth(), beijingNow.getUTCDate());
    
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    
    // è½¬æ¢ç›®æ ‡æ—¥æœŸåˆ°åŒ—äº¬æ—¶é—´
    const targetDate = new Date(date);
    const beijingTarget = new Date(targetDate.getTime() + 8 * 60 * 60 * 1000);
    const targetDay = new Date(beijingTarget.getUTCFullYear(), beijingTarget.getUTCMonth(), beijingTarget.getUTCDate());
    
    if (targetDay.getTime() === today.getTime()) {
        return 'ä»Šå¤©';
    } else if (targetDay.getTime() === yesterday.getTime()) {
        return 'æ˜¨å¤©';
    } else if (targetDay.getTime() === tomorrow.getTime()) {
        return 'æ˜å¤©';
    } else {
        // è¿”å›æ ¼å¼ï¼š2æœˆ13æ—¥(å‘¨å››)
        const month = targetDay.getMonth() + 1;
        const day = targetDay.getDate();
        const weekdays = ['å‘¨æ—¥', 'å‘¨ä¸€', 'å‘¨äºŒ', 'å‘¨ä¸‰', 'å‘¨å››', 'å‘¨äº”', 'å‘¨å…­'];
        const weekday = weekdays[targetDay.getDay()];
        return `${month}æœˆ${day}æ—¥(${weekday})`;
    }
}

/**
 * è®¡ç®—è¿›åº¦ç™¾åˆ†æ¯”ï¼ˆå’Œä½ ç½‘é¡µä¸Šä¸€æ¨¡ä¸€æ ·ï¼‰
 */
function calculateProgress(lastDate, nextDate, currentDate) {
    const last = new Date(lastDate);
    const next = new Date(nextDate);
    const current = new Date(currentDate);
    
    const lastDay = new Date(last.getFullYear(), last.getMonth(), last.getDate());
    const nextDay = new Date(next.getFullYear(), next.getMonth(), next.getDate());
    const currentDay = new Date(current.getFullYear(), current.getMonth(), current.getDate());
    
    const totalMs = nextDay - lastDay;
    const elapsedMs = currentDay - lastDay;
    
    let progress = (elapsedMs / totalMs) * 100;
    progress = Math.min(100, Math.max(0, progress));
    
    return Math.round(progress);
}

/**
 * è®¡ç®—ä¸‹ä¸€æ¬¡æé†’æ—¥æœŸ
 */
function calculateNextReminderDate(lastDate, intervalDays) {
    const last = new Date(lastDate);
    const next = new Date(last);
    next.setDate(next.getDate() + intervalDays);
    return next;
}

/**
 * å‘é€Telegramæ¶ˆæ¯ï¼ˆç²¾ç¾æ ¼å¼ç‰ˆï¼‰
 */
function sendTelegramMessage(message) {
    return new Promise((resolve) => {
        if (!TOKEN || !CHAT_ID) {
            console.log('âŒ æœªé…ç½®Tokenæˆ–Chat ID');
            resolve(false);
            return;
        }

        const data = JSON.stringify({
            chat_id: CHAT_ID,
            text: message,
            parse_mode: 'HTML',  // å¯ç”¨HTMLæ ¼å¼
            disable_web_page_preview: true
        });

        const req = https.request(
            `https://api.telegram.org/bot${TOKEN}/sendMessage`,
            {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Content-Length': Buffer.byteLength(data)
                }
            },
            (res) => {
                let response = '';
                res.on('data', chunk => response += chunk);
                res.on('end', () => {
                    console.log(`âœ… Telegramå“åº”: ${res.statusCode}`);
                    resolve(res.statusCode === 200);
                });
            }
        );

        req.on('error', (e) => {
            console.error('âŒ å‘é€å¤±è´¥:', e.message);
            resolve(false);
        });

        req.write(data);
        req.end();
    });
}

// ==================== ä¸»å‡½æ•° ====================

async function main() {
    console.log('='.repeat(50));
    console.log('ğŸš€ Telegramå®šæ—¶æé†’ç³»ç»Ÿ (ç²¾ç¾æ ¼å¼ç‰ˆ)');
    console.log('='.repeat(50));
    
    const today = getTodayDateString();
    const todayDate = new Date(today);
    console.log(`ğŸ“… åŒ—äº¬æ—¶é—´: ${today} (${formatDate(todayDate)})`);
    console.log(`ğŸ¤– Bot Token: ${TOKEN ? 'å·²é…ç½®' : 'æœªé…ç½®'}`);
    console.log(`ğŸ‘¤ Chat ID: ${CHAT_ID ? 'å·²é…ç½®' : 'æœªé…ç½®'}`);
    
    // 1. è¯»å–æé†’æ•°æ®
    let reminders = [];
    try {
        // å°è¯•è¯»å–æ ¹ç›®å½•çš„ reminders.json
        const rootFile = path.join(__dirname, '..', 'reminders.json');
        if (fs.existsSync(rootFile)) {
            reminders = JSON.parse(fs.readFileSync(rootFile, 'utf8'));
            console.log(`ğŸ“– å·²åŠ è½½ ${reminders.length} ä¸ªæé†’`);
            
            // ç¡®ä¿æ¯ä¸ªæé†’éƒ½æœ‰å¿…è¦çš„å­—æ®µ
            reminders.forEach(r => {
                if (!r.nextReminder) {
                    const nextDate = calculateNextReminderDate(r.lastUpdated, r.days);
                    r.nextReminder = nextDate.toISOString().split('T')[0];
                }
                if (r.enabled === undefined) r.enabled = true;
            });
        } else {
            // åˆ›å»ºé»˜è®¤æ•°æ®
            reminders = [
                { 
                    id: Date.now(), 
                    name: "ç½‘å®¿IPæ›´æ–°", 
                    lastUpdated: "2026-02-12", 
                    nextReminder: "2026-02-12", 
                    days: 3, 
                    enabled: true,
                    createdAt: new Date().toISOString()
                },
                { 
                    id: Date.now() + 1, 
                    name: "å‘¨æŠ¥æäº¤", 
                    lastUpdated: "2026-02-09", 
                    nextReminder: "2026-02-16", 
                    days: 7, 
                    enabled: true,
                    createdAt: new Date().toISOString()
                }
            ];
            console.log('ğŸ“ åˆ›å»ºé»˜è®¤æé†’');
        }
    } catch (e) {
        console.error('âŒ è¯»å–å¤±è´¥:', e.message);
        reminders = [];
    }
    
    // 2. ç­›é€‰ä»Šæ—¥åˆ°æœŸæé†’
    const dueReminders = reminders.filter(r => r.enabled !== false && r.nextReminder === today);
    console.log(`ğŸ” ä»Šæ—¥åˆ°æœŸæé†’: ${dueReminders.length} ä¸ª`);
    
    // 3. å‘é€æé†’ï¼ˆç²¾ç¾æ ¼å¼ï¼‰
    if (dueReminders.length > 0) {
        // ========== ç²¾ç¾æ¶ˆæ¯æ¨¡æ¿ï¼ˆå’Œä½ ç½‘é¡µé£æ ¼ä¸€è‡´ï¼‰ ==========
        let message = `ğŸ“¢ <b>æ¯æ—¥å®šæ—¶æé†’ Â· ${formatDate(todayDate)}</b>\n\n`;
        message += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n`;
        
        dueReminders.forEach((r, index) => {
            const lastDate = new Date(r.lastUpdated);
            const nextDate = calculateNextReminderDate(r.lastUpdated, r.days);
            const nextNextDate = calculateNextReminderDate(r.lastUpdated, r.days * 2);
            const progress = calculateProgress(r.lastUpdated, r.nextReminder, today);
            
            // è¿›åº¦æ¡è¡¨æƒ…
            let progressEmoji = 'ğŸŸ©';
            if (progress >= 100) progressEmoji = 'âœ…';
            else if (progress >= 90) progressEmoji = 'âš ï¸';
            else if (progress >= 50) progressEmoji = 'ğŸŸ¨';
            
            message += `<b>${index + 1}. ${r.name}</b>\n`;
            message += `   ğŸ“… ä¸Šæ¬¡æ›´æ–°: ${formatDate(lastDate)}\n`;
            message += `   â° ä¸‹æ¬¡æé†’: ${formatDate(nextDate)}\n`;
            message += `   ğŸ”„ ä¸‹ä¸‹æ¬¡: ${formatDate(nextNextDate)}\n`;
            message += `   ğŸ“Š é—´éš”: ${r.days}å¤©  ${progressEmoji} ${progress}%\n\n`;
        });
        
        message += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
        message += `ğŸ’¡ è¯·åŠæ—¶å¤„ç†ä»¥ä¸Šé¡¹ç›®\n`;
        message += `âš¡ å‘é€æ—¶é—´: ${new Date().toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai' })}`;
        
        const success = await sendTelegramMessage(message);
        
        if (success) {
            // æ›´æ–°æé†’æ—¥æœŸ
            dueReminders.forEach(r => {
                r.lastUpdated = today;
                const nextDate = calculateNextReminderDate(today, r.days);
                r.nextReminder = nextDate.toISOString().split('T')[0];
                r.lastNotified = new Date().toISOString();
            });
            console.log('âœ… å·²æ›´æ–°ä¸‹æ¬¡æé†’æ—¥æœŸ');
        }
    } else {
        console.log('â„¹ï¸ ä»Šæ—¥æ— åˆ°æœŸæé†’');
        
        // ç²¾ç¾å¿ƒè·³æ¶ˆæ¯ï¼ˆæ¯å‘¨ä¸‰å‘é€ä¸€æ¬¡ï¼‰
        const dayOfWeek = new Date().getDay();
        if (dayOfWeek === 3) {  // å‘¨ä¸‰
            await sendTelegramMessage(
                `ğŸ’“ <b>ç³»ç»Ÿå¿ƒè·³</b> Â· ${formatDate(todayDate)}\n\n` +
                `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n` +
                `âœ… ç³»ç»Ÿè¿è¡Œæ­£å¸¸\n` +
                `ğŸ“Š ä»Šæ—¥æ— åˆ°æœŸæé†’\n` +
                `ğŸ“ å½“å‰æé†’æ€»æ•°: ${reminders.length} ä¸ª\n\n` +
                `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n` +
                `âš¡ ä¸‹æ¬¡æ£€æŸ¥: æ˜å¤© 11:00`
            );
        }
    }
    
    // 4. ä¿å­˜æ•°æ®
    try {
        // åˆ›å»ºdataç›®å½•
        const dataDir = path.join(__dirname, '..', 'data');
        if (!fs.existsSync(dataDir)) {
            fs.mkdirSync(dataDir, { recursive: true });
        }
        
        // ä¿å­˜åˆ° data/reminders.json
        fs.writeFileSync(path.join(dataDir, 'reminders.json'), JSON.stringify(reminders, null, 2), 'utf8');
        // ä¿å­˜åˆ°æ ¹ç›®å½•
        fs.writeFileSync(path.join(__dirname, '..', 'reminders.json'), JSON.stringify(reminders, null, 2), 'utf8');
        
        console.log('ğŸ’¾ æ•°æ®å·²ä¿å­˜');
    } catch (e) {
        console.error('âŒ ä¿å­˜å¤±è´¥:', e.message);
    }
    
    console.log('='.repeat(50));
    console.log('âœ¨ æ‰§è¡Œå®Œæˆ');
    console.log('='.repeat(50));
}

// å¯åŠ¨
main().catch(error => {
    console.error('âŒ ç¨‹åºå¼‚å¸¸:', error);
    process.exit(1);
});
